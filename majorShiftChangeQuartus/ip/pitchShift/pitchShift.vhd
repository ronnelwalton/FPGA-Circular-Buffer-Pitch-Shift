-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\pitchShift\pitchShift.vhd
-- Created: 2022-05-07 23:06:07
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1.01725e-08
-- Target subsystem base rate: 1.01725e-08
-- Explicit user oversample request: 2048x
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        2.08333e-05
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- AudioOut                      ce_out        2.08333e-05
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: pitchShift
-- Source Path: pitchShift/pitchShift
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY pitchShift IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        AudioIn                           :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En23
        Pitch                             :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En23
        ce_out                            :   OUT   std_logic;
        AudioOut                          :   OUT   std_logic_vector(23 DOWNTO 0)  -- sfix24_En23
        );
END pitchShift;


ARCHITECTURE rtl OF pitchShift IS

  ATTRIBUTE multstyle : string;

  -- Component Declarations
  COMPONENT pitchShift_tc
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          clk_enable                      :   IN    std_logic;
          enb                             :   OUT   std_logic;
          enb_1_2048_0                    :   OUT   std_logic;
          enb_1_2048_1                    :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT modimpl_ntwk
    PORT( X                               :   IN    std_logic_vector(9 DOWNTO 0);  -- ufix10
          Y                               :   OUT   std_logic_vector(9 DOWNTO 0)  -- ufix10
          );
  END COMPONENT;

  COMPONENT modimpl_ntwk_block
    PORT( X                               :   IN    std_logic_vector(9 DOWNTO 0);  -- ufix10
          Y                               :   OUT   std_logic_vector(9 DOWNTO 0)  -- ufix10
          );
  END COMPONENT;

  COMPONENT DualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb_1_2048_0                    :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_dout                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          rd_dout                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  COMPONENT modimpl_ntwk_block1
    PORT( X                               :   IN    std_logic_vector(9 DOWNTO 0);  -- ufix10
          Y                               :   OUT   std_logic_vector(9 DOWNTO 0)  -- ufix10
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : pitchShift_tc
    USE ENTITY work.pitchShift_tc(rtl);

  FOR ALL : modimpl_ntwk
    USE ENTITY work.modimpl_ntwk(rtl);

  FOR ALL : modimpl_ntwk_block
    USE ENTITY work.modimpl_ntwk_block(rtl);

  FOR ALL : DualPortRAM_generic
    USE ENTITY work.DualPortRAM_generic(rtl);

  FOR ALL : modimpl_ntwk_block1
    USE ENTITY work.modimpl_ntwk_block1(rtl);

  -- Signals
  SIGNAL enb_1_2048_0                     : std_logic;
  SIGNAL enb                              : std_logic;
  SIGNAL enb_1_2048_1                     : std_logic;
  SIGNAL Constant2_out1                   : unsigned(23 DOWNTO 0);  -- ufix24_En23
  SIGNAL Constant2_out1_1                 : unsigned(23 DOWNTO 0);  -- ufix24_En23
  SIGNAL Constant2_out1_2                 : unsigned(23 DOWNTO 0);  -- ufix24_En23
  SIGNAL AudioIn_signed                   : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL AudioIn_1                        : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL tt1_ctrl_const_out               : std_logic;
  SIGNAL tt1_ctrl_delay_out               : std_logic;
  SIGNAL tt1_Initial_Val_out              : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL count_step                       : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL tt1_out1                         : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL count                            : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL tt1_out                          : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Modulo_by_Constant_HDL_Optimized_out1 : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL Modulo_by_Constant_HDL_Optimized_out1_unsigned : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Constant_out1                    : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Sum_out1                         : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Sum_out1_1                       : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Enable_out1                      : std_logic;
  SIGNAL tt2_ctrl_const_out               : std_logic;
  SIGNAL tt2_ctrl_delay_out               : std_logic;
  SIGNAL tt2_ctrl_delay_out_1             : std_logic;
  SIGNAL tt2_Initial_Val_out              : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count_step_1                     : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count_step_2                     : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL tt2_out1                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count_1                          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count_2                          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL tt2_bypass_reg                   : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL tt2_out                          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL tt2_out_1                        : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL tt2_out1_1                       : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Pitch_1                          : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Pitch_2                          : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Product_cast                     : signed(32 DOWNTO 0);  -- sfix33
  SIGNAL Product_mul_temp                 : signed(56 DOWNTO 0);  -- sfix57_En23
  SIGNAL Product_out1                     : signed(55 DOWNTO 0);  -- sfix56_En23
  SIGNAL Product_out1_1                   : signed(55 DOWNTO 0);  -- sfix56_En23
  SIGNAL Constant_out1_1                  : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Constant_out1_2                  : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Sum2_sub_cast                    : signed(56 DOWNTO 0);  -- sfix57_En23
  SIGNAL Sum2_sub_cast_1                  : signed(56 DOWNTO 0);  -- sfix57_En23
  SIGNAL Sum2_sub_temp                    : signed(56 DOWNTO 0);  -- sfix57_En23
  SIGNAL Sum2_out1                        : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL mod_by_constant_bypass_reg       : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Sum2_out1_1                      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Modulo_by_Constant_HDL_Optimized1_out1 : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL Modulo_by_Constant_HDL_Optimized1_out1_unsigned : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Sum1_out1                        : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL ringbuffer1_out1                 : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL ringbuffer1_out2                 : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL ringbuffer1_out2_1               : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL ringbuffer1_out2_2               : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Product1_cast                    : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Product1_mul_temp                : signed(48 DOWNTO 0);  -- sfix49_En46
  SIGNAL Product1_out1                    : signed(47 DOWNTO 0);  -- sfix48_En46
  SIGNAL Product1_out1_1                  : signed(47 DOWNTO 0);  -- sfix48_En46
  SIGNAL Product1_out1_2                  : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Constant1_out1                   : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Sum4_out1                        : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Modulo_by_Constant_HDL_Optimized2_out1 : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL Modulo_by_Constant_HDL_Optimized2_out1_unsigned : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Sum3_out1                        : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Sum3_out1_1                      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL ringbuffer2_out1                 : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL ringbuffer2_out2                 : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL ringbuffer2_out2_1               : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL ringbuffer2_out2_2               : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Sum5_add_cast                    : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Sum5_add_cast_1                  : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Sum5_add_temp                    : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Sum5_out1                        : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL t_bypass_reg                     : signed(23 DOWNTO 0);  -- sfix24
  SIGNAL Sum5_out1_1                      : signed(23 DOWNTO 0);  -- sfix24_En23

BEGIN
  u_pitchShift_tc : pitchShift_tc
    PORT MAP( clk => clk,
              reset => reset,
              clk_enable => clk_enable,
              enb => enb,
              enb_1_2048_0 => enb_1_2048_0,
              enb_1_2048_1 => enb_1_2048_1
              );

  u_mod_by_constant : modimpl_ntwk
    PORT MAP( X => std_logic_vector(tt1_out1),  -- ufix10
              Y => Modulo_by_Constant_HDL_Optimized_out1  -- ufix10
              );

  u_mod_by_constant_1 : modimpl_ntwk_block
    PORT MAP( X => std_logic_vector(Sum2_out1_1),  -- ufix10
              Y => Modulo_by_Constant_HDL_Optimized1_out1  -- ufix10
              );

  u_ringbuffer1 : DualPortRAM_generic
    GENERIC MAP( AddrWidth => 10,
                 DataWidth => 24
                 )
    PORT MAP( clk => clk,
              enb_1_2048_0 => enb_1_2048_0,
              wr_din => std_logic_vector(AudioIn_1),
              wr_addr => std_logic_vector(Sum_out1_1),
              wr_en => Enable_out1,
              rd_addr => std_logic_vector(Sum1_out1),
              wr_dout => ringbuffer1_out1,
              rd_dout => ringbuffer1_out2
              );

  u_mod_by_constant_2 : modimpl_ntwk_block1
    PORT MAP( X => std_logic_vector(Sum4_out1),  -- ufix10
              Y => Modulo_by_Constant_HDL_Optimized2_out1  -- ufix10
              );

  u_ringbuffer2 : DualPortRAM_generic
    GENERIC MAP( AddrWidth => 10,
                 DataWidth => 24
                 )
    PORT MAP( clk => clk,
              enb_1_2048_0 => enb_1_2048_0,
              wr_din => std_logic_vector(AudioIn_1),
              wr_addr => std_logic_vector(Sum3_out1_1),
              wr_en => Enable_out1,
              rd_addr => std_logic_vector(Sum1_out1),
              wr_dout => ringbuffer2_out1,
              rd_dout => ringbuffer2_out2
              );

  Constant2_out1 <= to_unsigned(16#200000#, 24);

  Constant2_out1_1 <= Constant2_out1;

  HwModeRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant2_out1_2 <= to_unsigned(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Constant2_out1_2 <= Constant2_out1_1;
      END IF;
    END IF;
  END PROCESS HwModeRegister_process;


  AudioIn_signed <= signed(AudioIn);

  reduced_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      AudioIn_1 <= to_signed(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_0 = '1' THEN
        AudioIn_1 <= AudioIn_signed;
      END IF;
    END IF;
  END PROCESS reduced_process;


  tt1_ctrl_const_out <= '1';

  tt1_ctrl_delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tt1_ctrl_delay_out <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_0 = '1' THEN
        tt1_ctrl_delay_out <= tt1_ctrl_const_out;
      END IF;
    END IF;
  END PROCESS tt1_ctrl_delay_process;


  tt1_Initial_Val_out <= to_unsigned(16#001#, 10);

  -- Free running, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  count_step <= to_unsigned(16#001#, 10);

  count <= tt1_out1 + count_step;

  tt1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tt1_out <= to_unsigned(16#000#, 10);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_0 = '1' THEN
        tt1_out <= count;
      END IF;
    END IF;
  END PROCESS tt1_process;


  
  tt1_out1 <= tt1_Initial_Val_out WHEN tt1_ctrl_delay_out = '0' ELSE
      tt1_out;

  Modulo_by_Constant_HDL_Optimized_out1_unsigned <= unsigned(Modulo_by_Constant_HDL_Optimized_out1);

  Constant_out1 <= to_unsigned(1, 32);

  Sum_out1 <= resize(resize(Modulo_by_Constant_HDL_Optimized_out1_unsigned, 33) + resize(Constant_out1, 33), 10);

  delayMatch3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Sum_out1_1 <= to_unsigned(16#000#, 10);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_0 = '1' THEN
        Sum_out1_1 <= Sum_out1;
      END IF;
    END IF;
  END PROCESS delayMatch3_process;


  Enable_out1 <= '1';

  tt2_ctrl_const_out <= '1';

  tt2_ctrl_delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tt2_ctrl_delay_out <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_0 = '1' THEN
        tt2_ctrl_delay_out <= tt2_ctrl_const_out;
      END IF;
    END IF;
  END PROCESS tt2_ctrl_delay_process;


  tt2_ctrl_delay_out_1 <= tt2_ctrl_delay_out;

  tt2_Initial_Val_out <= to_unsigned(1, 32);

  -- Free running, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  count_step_1 <= to_unsigned(1, 32);

  count_step_2 <= count_step_1;

  count_1 <= tt2_out1 + count_step_2;

  crp_out_delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      count_2 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        count_2 <= count_1;
      END IF;
    END IF;
  END PROCESS crp_out_delay_process;


  tt2_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tt2_bypass_reg <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_1 = '1' THEN
        tt2_bypass_reg <= count_2;
      END IF;
    END IF;
  END PROCESS tt2_bypass_process;

  
  tt2_out <= count_2 WHEN enb_1_2048_1 = '1' ELSE
      tt2_bypass_reg;

  tt2_out_1 <= tt2_out;

  
  tt2_out1 <= tt2_Initial_Val_out WHEN tt2_ctrl_delay_out_1 = '0' ELSE
      tt2_out_1;

  HwModeRegister2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tt2_out1_1 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        tt2_out1_1 <= tt2_out1;
      END IF;
    END IF;
  END PROCESS HwModeRegister2_process;


  Pitch_1 <= signed(Pitch);

  HwModeRegister3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Pitch_2 <= to_signed(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Pitch_2 <= Pitch_1;
      END IF;
    END IF;
  END PROCESS HwModeRegister3_process;


  Product_cast <= signed(resize(tt2_out1_1, 33));
  Product_mul_temp <= Product_cast * Pitch_2;
  Product_out1 <= Product_mul_temp(55 DOWNTO 0);

  PipelineRegister1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product_out1_1 <= to_signed(0, 56);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Product_out1_1 <= Product_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister1_process;


  Constant_out1_1 <= Constant_out1;

  delayMatch1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant_out1_2 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Constant_out1_2 <= Constant_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch1_process;


  Sum2_sub_cast <= resize(Product_out1_1, 57);
  Sum2_sub_cast_1 <= signed(resize(Constant_out1_2 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 57));
  Sum2_sub_temp <= Sum2_sub_cast - Sum2_sub_cast_1;
  Sum2_out1 <= unsigned(Sum2_sub_temp(32 DOWNTO 23));

  mod_by_constant_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mod_by_constant_bypass_reg <= to_unsigned(16#000#, 10);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_1 = '1' THEN
        mod_by_constant_bypass_reg <= Sum2_out1;
      END IF;
    END IF;
  END PROCESS mod_by_constant_bypass_process;

  
  Sum2_out1_1 <= Sum2_out1 WHEN enb_1_2048_1 = '1' ELSE
      mod_by_constant_bypass_reg;

  Modulo_by_Constant_HDL_Optimized1_out1_unsigned <= unsigned(Modulo_by_Constant_HDL_Optimized1_out1);

  Sum1_out1 <= resize(resize(Modulo_by_Constant_HDL_Optimized1_out1_unsigned, 33) + resize(Constant_out1, 33), 10);

  ringbuffer1_out2_1 <= signed(ringbuffer1_out2);

  HwModeRegister1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      ringbuffer1_out2_2 <= to_signed(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        ringbuffer1_out2_2 <= ringbuffer1_out2_1;
      END IF;
    END IF;
  END PROCESS HwModeRegister1_process;


  Product1_cast <= signed(resize(Constant2_out1_2, 25));
  Product1_mul_temp <= Product1_cast * ringbuffer1_out2_2;
  Product1_out1 <= Product1_mul_temp(47 DOWNTO 0);

  PipelineRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product1_out1_1 <= to_signed(0, 48);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Product1_out1_1 <= Product1_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister_process;


  
  Product1_out1_2 <= X"7FFFFF" WHEN (Product1_out1_1(47) = '0') AND (Product1_out1_1(46) /= '0') ELSE
      X"800000" WHEN (Product1_out1_1(47) = '1') AND (Product1_out1_1(46) /= '1') ELSE
      Product1_out1_1(46 DOWNTO 23);

  Constant1_out1 <= to_unsigned(512, 32);

  Sum4_out1 <= resize(resize(tt1_out1, 33) + resize(Constant1_out1, 33), 10);

  Modulo_by_Constant_HDL_Optimized2_out1_unsigned <= unsigned(Modulo_by_Constant_HDL_Optimized2_out1);

  Sum3_out1 <= resize(resize(Modulo_by_Constant_HDL_Optimized2_out1_unsigned, 33) + resize(Constant_out1, 33), 10);

  delayMatch5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Sum3_out1_1 <= to_unsigned(16#000#, 10);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_0 = '1' THEN
        Sum3_out1_1 <= Sum3_out1;
      END IF;
    END IF;
  END PROCESS delayMatch5_process;


  ringbuffer2_out2_1 <= signed(ringbuffer2_out2);

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      ringbuffer2_out2_2 <= to_signed(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        ringbuffer2_out2_2 <= ringbuffer2_out2_1;
      END IF;
    END IF;
  END PROCESS delayMatch_process;


  Sum5_add_cast <= resize(Product1_out1_2, 25);
  Sum5_add_cast_1 <= resize(ringbuffer2_out2_2, 25);
  Sum5_add_temp <= Sum5_add_cast + Sum5_add_cast_1;
  
  Sum5_out1 <= X"7FFFFF" WHEN (Sum5_add_temp(24) = '0') AND (Sum5_add_temp(23) /= '0') ELSE
      X"800000" WHEN (Sum5_add_temp(24) = '1') AND (Sum5_add_temp(23) /= '1') ELSE
      Sum5_add_temp(23 DOWNTO 0);

  t_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      t_bypass_reg <= to_signed(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_1 = '1' THEN
        t_bypass_reg <= Sum5_out1;
      END IF;
    END IF;
  END PROCESS t_bypass_process;

  
  Sum5_out1_1 <= Sum5_out1 WHEN enb_1_2048_1 = '1' ELSE
      t_bypass_reg;

  AudioOut <= std_logic_vector(Sum5_out1_1);

  ce_out <= enb_1_2048_1;

END rtl;

