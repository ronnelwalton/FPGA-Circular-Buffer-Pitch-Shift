-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\majorChangeShift\majorChangeShift.vhd
-- Created: 2022-05-08 08:53:05
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1.01725e-08
-- Target subsystem base rate: 1.01725e-08
-- Explicit user oversample request: 2048x
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        2.08333e-05
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- AudioOut                      ce_out        2.08333e-05
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: majorChangeShift
-- Source Path: majorChangeShift/majorChangeShift
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY majorChangeShift IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        AudioIn                           :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En23
        Pitch1                            :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En23
        Pitch2                            :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En23
        ce_out                            :   OUT   std_logic;
        AudioOut                          :   OUT   std_logic_vector(23 DOWNTO 0)  -- sfix24_En23
        );
END majorChangeShift;


ARCHITECTURE rtl OF majorChangeShift IS

  ATTRIBUTE multstyle : string;

  -- Component Declarations
  COMPONENT majorChangeShift_tc
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          clk_enable                      :   IN    std_logic;
          enb                             :   OUT   std_logic;
          enb_1_2048_0                    :   OUT   std_logic;
          enb_1_2048_1                    :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT modimpl_ntwk1
    PORT( X                               :   IN    std_logic_vector(9 DOWNTO 0);  -- ufix10
          Y                               :   OUT   std_logic_vector(9 DOWNTO 0)  -- ufix10
          );
  END COMPONENT;

  COMPONENT modimpl_ntwk_block2
    PORT( X                               :   IN    std_logic_vector(9 DOWNTO 0);  -- ufix10
          Y                               :   OUT   std_logic_vector(9 DOWNTO 0)  -- ufix10
          );
  END COMPONENT;

  COMPONENT DualPortRAM_generic1
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb_1_2048_0                    :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_dout                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          rd_dout                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  COMPONENT modimpl_ntwk_block3
    PORT( X                               :   IN    std_logic_vector(9 DOWNTO 0);  -- ufix10
          Y                               :   OUT   std_logic_vector(9 DOWNTO 0)  -- ufix10
          );
  END COMPONENT;

  COMPONENT modimpl_ntwk_block4
    PORT( X                               :   IN    std_logic_vector(9 DOWNTO 0);  -- ufix10
          Y                               :   OUT   std_logic_vector(9 DOWNTO 0)  -- ufix10
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : majorChangeShift_tc
    USE ENTITY work.majorChangeShift_tc(rtl);

  FOR ALL : modimpl_ntwk1
    USE ENTITY work.modimpl_ntwk1(rtl);

  FOR ALL : modimpl_ntwk_block2
    USE ENTITY work.modimpl_ntwk_block2(rtl);

  FOR ALL : DualPortRAM_generic1
    USE ENTITY work.DualPortRAM_generic1(rtl);

  FOR ALL : modimpl_ntwk_block3
    USE ENTITY work.modimpl_ntwk_block3(rtl);

  FOR ALL : modimpl_ntwk_block4
    USE ENTITY work.modimpl_ntwk_block4(rtl);

  -- Signals
  SIGNAL enb_1_2048_0                     : std_logic;
  SIGNAL enb                              : std_logic;
  SIGNAL enb_1_2048_1                     : std_logic;
  SIGNAL Constant2_out1                   : unsigned(23 DOWNTO 0);  -- ufix24_En23
  SIGNAL Constant2_out1_1                 : unsigned(23 DOWNTO 0);  -- ufix24_En23
  SIGNAL Constant2_out1_2                 : unsigned(23 DOWNTO 0);  -- ufix24_En23
  SIGNAL AudioIn_signed                   : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL AudioIn_1                        : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL tt1_ctrl_const_out               : std_logic;
  SIGNAL tt1_ctrl_delay_out               : std_logic;
  SIGNAL tt1_Initial_Val_out              : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL count_step                       : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL tt1_out1                         : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL count                            : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL tt1_out                          : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Modulo_by_Constant_HDL_Optimized_out1 : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL Modulo_by_Constant_HDL_Optimized_out1_unsigned : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Constant_out1                    : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Sum_out1                         : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Sum_out1_1                       : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Enable_out1                      : std_logic;
  SIGNAL tt2_ctrl_const_out               : std_logic;
  SIGNAL tt2_ctrl_delay_out               : std_logic;
  SIGNAL tt2_ctrl_delay_out_1             : std_logic;
  SIGNAL tt2_Initial_Val_out              : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count_step_1                     : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count_step_2                     : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL tt2_out1                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count_1                          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count_2                          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL tt2_bypass_reg                   : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL tt2_out                          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL tt2_out_1                        : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL tt2_out1_1                       : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Pitch1_1                         : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Pitch1_2                         : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Product_cast                     : signed(32 DOWNTO 0);  -- sfix33
  SIGNAL Product_mul_temp                 : signed(56 DOWNTO 0);  -- sfix57_En23
  SIGNAL Product_out1                     : signed(55 DOWNTO 0);  -- sfix56_En23
  SIGNAL Product_out1_1                   : signed(55 DOWNTO 0);  -- sfix56_En23
  SIGNAL Constant_out1_1                  : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Constant_out1_2                  : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Sum2_sub_cast                    : signed(56 DOWNTO 0);  -- sfix57_En23
  SIGNAL Sum2_sub_cast_1                  : signed(56 DOWNTO 0);  -- sfix57_En23
  SIGNAL Sum2_sub_temp                    : signed(56 DOWNTO 0);  -- sfix57_En23
  SIGNAL Sum2_out1                        : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL mod_by_constant_bypass_reg       : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Sum2_out1_1                      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Modulo_by_Constant_HDL_Optimized1_out1 : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL Modulo_by_Constant_HDL_Optimized1_out1_unsigned : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Sum1_out1                        : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL ringbuffer1_out1                 : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL ringbuffer1_out2                 : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL ringbuffer1_out2_1               : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL ringbuffer1_out2_2               : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Product1_cast                    : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Product1_mul_temp                : signed(48 DOWNTO 0);  -- sfix49_En46
  SIGNAL Product1_out1                    : signed(47 DOWNTO 0);  -- sfix48_En46
  SIGNAL Product1_out1_1                  : signed(47 DOWNTO 0);  -- sfix48_En46
  SIGNAL Product1_out1_2                  : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Constant1_out1                   : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Sum4_out1                        : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Modulo_by_Constant_HDL_Optimized2_out1 : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL Modulo_by_Constant_HDL_Optimized2_out1_unsigned : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Sum3_out1                        : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Sum3_out1_1                      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL ringbuffer2_out1                 : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL ringbuffer2_out2                 : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL ringbuffer2_out2_1               : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Constant5_out1                   : unsigned(23 DOWNTO 0);  -- ufix24_En23
  SIGNAL Constant5_out1_1                 : unsigned(23 DOWNTO 0);  -- ufix24_En23
  SIGNAL Constant5_out1_2                 : unsigned(23 DOWNTO 0);  -- ufix24_En23
  SIGNAL tt4_ctrl_const_out               : std_logic;
  SIGNAL tt4_ctrl_delay_out               : std_logic;
  SIGNAL tt4_ctrl_delay_out_1             : std_logic;
  SIGNAL tt4_Initial_Val_out              : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count_step_3                     : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count_step_4                     : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL tt4_out1                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count_3                          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count_4                          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL tt4_bypass_reg                   : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL tt4_out                          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL tt4_out_1                        : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL tt4_out1_1                       : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Pitch2_1                         : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Pitch2_2                         : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Product2_cast                    : signed(32 DOWNTO 0);  -- sfix33
  SIGNAL Product2_mul_temp                : signed(56 DOWNTO 0);  -- sfix57_En23
  SIGNAL Product2_out1                    : signed(55 DOWNTO 0);  -- sfix56_En23
  SIGNAL Product2_out1_1                  : signed(55 DOWNTO 0);  -- sfix56_En23
  SIGNAL Constant3_out1                   : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Sum8_sub_cast                    : signed(56 DOWNTO 0);  -- sfix57_En23
  SIGNAL Sum8_sub_cast_1                  : signed(56 DOWNTO 0);  -- sfix57_En23
  SIGNAL Sum8_sub_temp                    : signed(56 DOWNTO 0);  -- sfix57_En23
  SIGNAL Sum8_out1                        : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL mod_by_constant1_bypass_reg      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Sum8_out1_1                      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Modulo_by_Constant_HDL_Optimized4_out1 : std_logic_vector(9 DOWNTO 0);  -- ufix10
  SIGNAL Modulo_by_Constant_HDL_Optimized4_out1_unsigned : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL Constant3_out1_1                 : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Constant3_out1_2                 : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Sum7_out1                        : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL ringbuffer3_out1                 : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL ringbuffer3_out2                 : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL ringbuffer3_out2_1               : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL ringbuffer3_out2_2               : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Product3_cast                    : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Product3_mul_temp                : signed(48 DOWNTO 0);  -- sfix49_En46
  SIGNAL Product3_out1                    : signed(47 DOWNTO 0);  -- sfix48_En46
  SIGNAL ringbuffer2_out2_2               : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Sum5_stage2_add_cast             : signed(25 DOWNTO 0);  -- sfix26_En23
  SIGNAL Sum5_stage2_add_cast_1           : signed(25 DOWNTO 0);  -- sfix26_En23
  SIGNAL Sum5_stage2_add_temp             : signed(25 DOWNTO 0);  -- sfix26_En23
  SIGNAL Sum5_op_stage1                   : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Product3_out1_1                  : signed(47 DOWNTO 0);  -- sfix48_En46
  SIGNAL Product3_out1_2                  : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Sum5_stage3_add_cast             : signed(25 DOWNTO 0);  -- sfix26_En23
  SIGNAL Sum5_stage3_add_cast_1           : signed(25 DOWNTO 0);  -- sfix26_En23
  SIGNAL Sum5_op_stage2                   : signed(25 DOWNTO 0);  -- sfix26_En23
  SIGNAL ringbuffer4_out1                 : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL ringbuffer4_out2                 : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL ringbuffer4_out2_1               : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL ringbuffer4_out2_2               : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Sum5_stage4_add_cast             : signed(26 DOWNTO 0);  -- sfix27_En23
  SIGNAL Sum5_stage4_add_cast_1           : signed(25 DOWNTO 0);  -- sfix26_En23
  SIGNAL Sum5_stage4_add_cast_2           : signed(26 DOWNTO 0);  -- sfix27_En23
  SIGNAL Sum5_stage4_add_temp             : signed(26 DOWNTO 0);  -- sfix27_En23
  SIGNAL Sum5_stage4_cast                 : signed(25 DOWNTO 0);  -- sfix26_En23
  SIGNAL Sum5_out1                        : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL t_bypass_reg                     : signed(23 DOWNTO 0);  -- sfix24
  SIGNAL Sum5_out1_1                      : signed(23 DOWNTO 0);  -- sfix24_En23

BEGIN
  u_majorChangeShift_tc : majorChangeShift_tc
    PORT MAP( clk => clk,
              reset => reset,
              clk_enable => clk_enable,
              enb => enb,
              enb_1_2048_0 => enb_1_2048_0,
              enb_1_2048_1 => enb_1_2048_1
              );

  u_mod_by_constant : modimpl_ntwk1
    PORT MAP( X => std_logic_vector(tt1_out1),  -- ufix10
              Y => Modulo_by_Constant_HDL_Optimized_out1  -- ufix10
              );

  u_mod_by_constant_1 : modimpl_ntwk_block2
    PORT MAP( X => std_logic_vector(Sum2_out1_1),  -- ufix10
              Y => Modulo_by_Constant_HDL_Optimized1_out1  -- ufix10
              );

  u_ringbuffer1 : DualPortRAM_generic1
    GENERIC MAP( AddrWidth => 10,
                 DataWidth => 24
                 )
    PORT MAP( clk => clk,
              enb_1_2048_0 => enb_1_2048_0,
              wr_din => std_logic_vector(AudioIn_1),
              wr_addr => std_logic_vector(Sum_out1_1),
              wr_en => Enable_out1,
              rd_addr => std_logic_vector(Sum1_out1),
              wr_dout => ringbuffer1_out1,
              rd_dout => ringbuffer1_out2
              );

  u_mod_by_constant_2 : modimpl_ntwk_block3
    PORT MAP( X => std_logic_vector(Sum4_out1),  -- ufix10
              Y => Modulo_by_Constant_HDL_Optimized2_out1  -- ufix10
              );

  u_ringbuffer2 : DualPortRAM_generic
    GENERIC MAP( AddrWidth => 10,
                 DataWidth => 24
                 )
    PORT MAP( clk => clk,
              enb_1_2048_0 => enb_1_2048_0,
              wr_din => std_logic_vector(AudioIn_1),
              wr_addr => std_logic_vector(Sum3_out1_1),
              wr_en => Enable_out1,
              rd_addr => std_logic_vector(Sum1_out1),
              wr_dout => ringbuffer2_out1,
              rd_dout => ringbuffer2_out2
              );

  u_mod_by_constant_3 : modimpl_ntwk_block4
    PORT MAP( X => std_logic_vector(Sum8_out1_1),  -- ufix10
              Y => Modulo_by_Constant_HDL_Optimized4_out1  -- ufix10
              );

  u_ringbuffer3 : DualPortRAM_generic1
    GENERIC MAP( AddrWidth => 10,
                 DataWidth => 24
                 )
    PORT MAP( clk => clk,
              enb_1_2048_0 => enb_1_2048_0,
              wr_din => std_logic_vector(AudioIn_1),
              wr_addr => std_logic_vector(Sum_out1_1),
              wr_en => Enable_out1,
              rd_addr => std_logic_vector(Sum7_out1),
              wr_dout => ringbuffer3_out1,
              rd_dout => ringbuffer3_out2
              );

  u_ringbuffer4 : DualPortRAM_generic1
    GENERIC MAP( AddrWidth => 10,
                 DataWidth => 24
                 )
    PORT MAP( clk => clk,
              enb_1_2048_0 => enb_1_2048_0,
              wr_din => std_logic_vector(AudioIn_1),
              wr_addr => std_logic_vector(Sum3_out1_1),
              wr_en => Enable_out1,
              rd_addr => std_logic_vector(Sum7_out1),
              wr_dout => ringbuffer4_out1,
              rd_dout => ringbuffer4_out2
              );

  Constant2_out1 <= to_unsigned(16#200000#, 24);

  Constant2_out1_1 <= Constant2_out1;

  HwModeRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant2_out1_2 <= to_unsigned(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Constant2_out1_2 <= Constant2_out1_1;
      END IF;
    END IF;
  END PROCESS HwModeRegister_process;


  AudioIn_signed <= signed(AudioIn);

  reduced_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      AudioIn_1 <= to_signed(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_0 = '1' THEN
        AudioIn_1 <= AudioIn_signed;
      END IF;
    END IF;
  END PROCESS reduced_process;


  tt1_ctrl_const_out <= '1';

  tt1_ctrl_delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tt1_ctrl_delay_out <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_0 = '1' THEN
        tt1_ctrl_delay_out <= tt1_ctrl_const_out;
      END IF;
    END IF;
  END PROCESS tt1_ctrl_delay_process;


  tt1_Initial_Val_out <= to_unsigned(16#001#, 10);

  -- Free running, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  count_step <= to_unsigned(16#001#, 10);

  count <= tt1_out1 + count_step;

  tt1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tt1_out <= to_unsigned(16#000#, 10);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_0 = '1' THEN
        tt1_out <= count;
      END IF;
    END IF;
  END PROCESS tt1_process;


  
  tt1_out1 <= tt1_Initial_Val_out WHEN tt1_ctrl_delay_out = '0' ELSE
      tt1_out;

  Modulo_by_Constant_HDL_Optimized_out1_unsigned <= unsigned(Modulo_by_Constant_HDL_Optimized_out1);

  Constant_out1 <= to_unsigned(1, 32);

  Sum_out1 <= resize(resize(Modulo_by_Constant_HDL_Optimized_out1_unsigned, 33) + resize(Constant_out1, 33), 10);

  reduced_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Sum_out1_1 <= to_unsigned(16#000#, 10);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_0 = '1' THEN
        Sum_out1_1 <= Sum_out1;
      END IF;
    END IF;
  END PROCESS reduced_1_process;


  Enable_out1 <= '1';

  tt2_ctrl_const_out <= '1';

  tt2_ctrl_delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tt2_ctrl_delay_out <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_0 = '1' THEN
        tt2_ctrl_delay_out <= tt2_ctrl_const_out;
      END IF;
    END IF;
  END PROCESS tt2_ctrl_delay_process;


  tt2_ctrl_delay_out_1 <= tt2_ctrl_delay_out;

  tt2_Initial_Val_out <= to_unsigned(1, 32);

  -- Free running, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  count_step_1 <= to_unsigned(1, 32);

  count_step_2 <= count_step_1;

  count_1 <= tt2_out1 + count_step_2;

  crp_out_delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      count_2 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        count_2 <= count_1;
      END IF;
    END IF;
  END PROCESS crp_out_delay_process;


  tt2_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tt2_bypass_reg <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_1 = '1' THEN
        tt2_bypass_reg <= count_2;
      END IF;
    END IF;
  END PROCESS tt2_bypass_process;

  
  tt2_out <= count_2 WHEN enb_1_2048_1 = '1' ELSE
      tt2_bypass_reg;

  tt2_out_1 <= tt2_out;

  
  tt2_out1 <= tt2_Initial_Val_out WHEN tt2_ctrl_delay_out_1 = '0' ELSE
      tt2_out_1;

  HwModeRegister4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tt2_out1_1 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        tt2_out1_1 <= tt2_out1;
      END IF;
    END IF;
  END PROCESS HwModeRegister4_process;


  Pitch1_1 <= signed(Pitch1);

  HwModeRegister5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Pitch1_2 <= to_signed(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Pitch1_2 <= Pitch1_1;
      END IF;
    END IF;
  END PROCESS HwModeRegister5_process;


  Product_cast <= signed(resize(tt2_out1_1, 33));
  Product_mul_temp <= Product_cast * Pitch1_2;
  Product_out1 <= Product_mul_temp(55 DOWNTO 0);

  PipelineRegister2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product_out1_1 <= to_signed(0, 56);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Product_out1_1 <= Product_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister2_process;


  Constant_out1_1 <= Constant_out1;

  delayMatch2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant_out1_2 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Constant_out1_2 <= Constant_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch2_process;


  Sum2_sub_cast <= resize(Product_out1_1, 57);
  Sum2_sub_cast_1 <= signed(resize(Constant_out1_2 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 57));
  Sum2_sub_temp <= Sum2_sub_cast - Sum2_sub_cast_1;
  Sum2_out1 <= unsigned(Sum2_sub_temp(32 DOWNTO 23));

  mod_by_constant_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mod_by_constant_bypass_reg <= to_unsigned(16#000#, 10);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_1 = '1' THEN
        mod_by_constant_bypass_reg <= Sum2_out1;
      END IF;
    END IF;
  END PROCESS mod_by_constant_bypass_process;

  
  Sum2_out1_1 <= Sum2_out1 WHEN enb_1_2048_1 = '1' ELSE
      mod_by_constant_bypass_reg;

  Modulo_by_Constant_HDL_Optimized1_out1_unsigned <= unsigned(Modulo_by_Constant_HDL_Optimized1_out1);

  Sum1_out1 <= resize(resize(Modulo_by_Constant_HDL_Optimized1_out1_unsigned, 33) + resize(Constant_out1, 33), 10);

  ringbuffer1_out2_1 <= signed(ringbuffer1_out2);

  HwModeRegister1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      ringbuffer1_out2_2 <= to_signed(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        ringbuffer1_out2_2 <= ringbuffer1_out2_1;
      END IF;
    END IF;
  END PROCESS HwModeRegister1_process;


  Product1_cast <= signed(resize(Constant2_out1_2, 25));
  Product1_mul_temp <= Product1_cast * ringbuffer1_out2_2;
  Product1_out1 <= Product1_mul_temp(47 DOWNTO 0);

  PipelineRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product1_out1_1 <= to_signed(0, 48);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Product1_out1_1 <= Product1_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister_process;


  
  Product1_out1_2 <= X"7FFFFF" WHEN (Product1_out1_1(47) = '0') AND (Product1_out1_1(46) /= '0') ELSE
      X"800000" WHEN (Product1_out1_1(47) = '1') AND (Product1_out1_1(46) /= '1') ELSE
      Product1_out1_1(46 DOWNTO 23);

  Constant1_out1 <= to_unsigned(512, 32);

  Sum4_out1 <= resize(resize(tt1_out1, 33) + resize(Constant1_out1, 33), 10);

  Modulo_by_Constant_HDL_Optimized2_out1_unsigned <= unsigned(Modulo_by_Constant_HDL_Optimized2_out1);

  Sum3_out1 <= resize(resize(Modulo_by_Constant_HDL_Optimized2_out1_unsigned, 33) + resize(Constant_out1, 33), 10);

  reduced_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Sum3_out1_1 <= to_unsigned(16#000#, 10);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_0 = '1' THEN
        Sum3_out1_1 <= Sum3_out1;
      END IF;
    END IF;
  END PROCESS reduced_2_process;


  ringbuffer2_out2_1 <= signed(ringbuffer2_out2);

  Constant5_out1 <= to_unsigned(16#200000#, 24);

  Constant5_out1_1 <= Constant5_out1;

  HwModeRegister2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant5_out1_2 <= to_unsigned(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Constant5_out1_2 <= Constant5_out1_1;
      END IF;
    END IF;
  END PROCESS HwModeRegister2_process;


  tt4_ctrl_const_out <= '1';

  tt4_ctrl_delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tt4_ctrl_delay_out <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_0 = '1' THEN
        tt4_ctrl_delay_out <= tt4_ctrl_const_out;
      END IF;
    END IF;
  END PROCESS tt4_ctrl_delay_process;


  tt4_ctrl_delay_out_1 <= tt4_ctrl_delay_out;

  tt4_Initial_Val_out <= to_unsigned(1, 32);

  -- Free running, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  count_step_3 <= to_unsigned(1, 32);

  count_step_4 <= count_step_3;

  count_3 <= tt4_out1 + count_step_4;

  crp_out_delay1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      count_4 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        count_4 <= count_3;
      END IF;
    END IF;
  END PROCESS crp_out_delay1_process;


  tt4_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tt4_bypass_reg <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_1 = '1' THEN
        tt4_bypass_reg <= count_4;
      END IF;
    END IF;
  END PROCESS tt4_bypass_process;

  
  tt4_out <= count_4 WHEN enb_1_2048_1 = '1' ELSE
      tt4_bypass_reg;

  tt4_out_1 <= tt4_out;

  
  tt4_out1 <= tt4_Initial_Val_out WHEN tt4_ctrl_delay_out_1 = '0' ELSE
      tt4_out_1;

  HwModeRegister6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tt4_out1_1 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        tt4_out1_1 <= tt4_out1;
      END IF;
    END IF;
  END PROCESS HwModeRegister6_process;


  Pitch2_1 <= signed(Pitch2);

  HwModeRegister7_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Pitch2_2 <= to_signed(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Pitch2_2 <= Pitch2_1;
      END IF;
    END IF;
  END PROCESS HwModeRegister7_process;


  Product2_cast <= signed(resize(tt4_out1_1, 33));
  Product2_mul_temp <= Product2_cast * Pitch2_2;
  Product2_out1 <= Product2_mul_temp(55 DOWNTO 0);

  PipelineRegister3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product2_out1_1 <= to_signed(0, 56);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Product2_out1_1 <= Product2_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister3_process;


  Constant3_out1 <= to_unsigned(1, 32);

  Sum8_sub_cast <= resize(Product2_out1_1, 57);
  Sum8_sub_cast_1 <= signed(resize(Constant3_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 57));
  Sum8_sub_temp <= Sum8_sub_cast - Sum8_sub_cast_1;
  Sum8_out1 <= unsigned(Sum8_sub_temp(32 DOWNTO 23));

  mod_by_constant1_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mod_by_constant1_bypass_reg <= to_unsigned(16#000#, 10);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_1 = '1' THEN
        mod_by_constant1_bypass_reg <= Sum8_out1;
      END IF;
    END IF;
  END PROCESS mod_by_constant1_bypass_process;

  
  Sum8_out1_1 <= Sum8_out1 WHEN enb_1_2048_1 = '1' ELSE
      mod_by_constant1_bypass_reg;

  Modulo_by_Constant_HDL_Optimized4_out1_unsigned <= unsigned(Modulo_by_Constant_HDL_Optimized4_out1);

  Sum71_output_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant3_out1_1 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_1 = '1' THEN
        Constant3_out1_1 <= Constant3_out1;
      END IF;
    END IF;
  END PROCESS Sum71_output_process;


  delayMatch5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Constant3_out1_2 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_0 = '1' THEN
        Constant3_out1_2 <= Constant3_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch5_process;


  Sum7_out1 <= resize(resize(Modulo_by_Constant_HDL_Optimized4_out1_unsigned, 33) + resize(Constant3_out1_2, 33), 10);

  ringbuffer3_out2_1 <= signed(ringbuffer3_out2);

  HwModeRegister3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      ringbuffer3_out2_2 <= to_signed(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        ringbuffer3_out2_2 <= ringbuffer3_out2_1;
      END IF;
    END IF;
  END PROCESS HwModeRegister3_process;


  Product3_cast <= signed(resize(Constant5_out1_2, 25));
  Product3_mul_temp <= Product3_cast * ringbuffer3_out2_2;
  Product3_out1 <= Product3_mul_temp(47 DOWNTO 0);

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      ringbuffer2_out2_2 <= to_signed(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        ringbuffer2_out2_2 <= ringbuffer2_out2_1;
      END IF;
    END IF;
  END PROCESS delayMatch_process;


  Sum5_stage2_add_cast <= resize(Product1_out1_2, 26);
  Sum5_stage2_add_cast_1 <= resize(ringbuffer2_out2_2, 26);
  Sum5_stage2_add_temp <= Sum5_stage2_add_cast + Sum5_stage2_add_cast_1;
  
  Sum5_op_stage1 <= "0111111111111111111111111" WHEN (Sum5_stage2_add_temp(25) = '0') AND (Sum5_stage2_add_temp(24) /= '0') ELSE
      "1000000000000000000000000" WHEN (Sum5_stage2_add_temp(25) = '1') AND (Sum5_stage2_add_temp(24) /= '1') ELSE
      Sum5_stage2_add_temp(24 DOWNTO 0);

  PipelineRegister1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product3_out1_1 <= to_signed(0, 48);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Product3_out1_1 <= Product3_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister1_process;


  
  Product3_out1_2 <= X"7FFFFF" WHEN (Product3_out1_1(47) = '0') AND (Product3_out1_1(46) /= '0') ELSE
      X"800000" WHEN (Product3_out1_1(47) = '1') AND (Product3_out1_1(46) /= '1') ELSE
      Product3_out1_1(46 DOWNTO 23);

  Sum5_stage3_add_cast <= resize(Sum5_op_stage1, 26);
  Sum5_stage3_add_cast_1 <= resize(Product3_out1_2, 26);
  Sum5_op_stage2 <= Sum5_stage3_add_cast + Sum5_stage3_add_cast_1;

  ringbuffer4_out2_1 <= signed(ringbuffer4_out2);

  delayMatch1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      ringbuffer4_out2_2 <= to_signed(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        ringbuffer4_out2_2 <= ringbuffer4_out2_1;
      END IF;
    END IF;
  END PROCESS delayMatch1_process;


  Sum5_stage4_add_cast <= resize(Sum5_op_stage2, 27);
  Sum5_stage4_add_cast_1 <= resize(ringbuffer4_out2_2, 26);
  Sum5_stage4_add_cast_2 <= resize(Sum5_stage4_add_cast_1, 27);
  Sum5_stage4_add_temp <= Sum5_stage4_add_cast + Sum5_stage4_add_cast_2;
  
  Sum5_stage4_cast <= "01111111111111111111111111" WHEN (Sum5_stage4_add_temp(26) = '0') AND (Sum5_stage4_add_temp(25) /= '0') ELSE
      "10000000000000000000000000" WHEN (Sum5_stage4_add_temp(26) = '1') AND (Sum5_stage4_add_temp(25) /= '1') ELSE
      Sum5_stage4_add_temp(25 DOWNTO 0);
  
  Sum5_out1 <= X"7FFFFF" WHEN (Sum5_stage4_cast(25) = '0') AND (Sum5_stage4_cast(24 DOWNTO 23) /= "00") ELSE
      X"800000" WHEN (Sum5_stage4_cast(25) = '1') AND (Sum5_stage4_cast(24 DOWNTO 23) /= "11") ELSE
      Sum5_stage4_cast(23 DOWNTO 0);

  t_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      t_bypass_reg <= to_signed(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2048_1 = '1' THEN
        t_bypass_reg <= Sum5_out1;
      END IF;
    END IF;
  END PROCESS t_bypass_process;

  
  Sum5_out1_1 <= Sum5_out1 WHEN enb_1_2048_1 = '1' ELSE
      t_bypass_reg;

  AudioOut <= std_logic_vector(Sum5_out1_1);

  ce_out <= enb_1_2048_1;

END rtl;

